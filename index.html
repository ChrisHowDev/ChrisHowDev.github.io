<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Portfolio</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }
        
        header {
            background: #2c3e50;
            color: white;
            padding: 2rem 1rem;
            text-align: center;
        }
        
        header h1 {
            margin-bottom: 0.5rem;
        }
        
        header p {
            opacity: 0.9;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }
        
        .project {
            background: white;
            margin-bottom: 2rem;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .project-media {
            width: 100%;
            max-height: 400px;
            object-fit: cover;
            display: block;
        }
        
        .media-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
            padding: 1rem;
            background: #fafafa;
        }
        
        .media-gallery img,
        .media-gallery video {
            width: 100%;
            height: 250px;
            object-fit: cover;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .media-gallery img:hover,
        .media-gallery video:hover {
            transform: scale(1.02);
        }
        
        .project-content {
            padding: 1.5rem;
        }
        
        .project-content h2 {
            margin-bottom: 0.5rem;
            color: #2c3e50;
        }
        
        .project-content p {
            color: #666;
            margin-bottom: 1rem;
        }
        
        .tags {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .tag {
            background: #ecf0f1;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.875rem;
            color: #555;
        }
        
        footer {
            text-align: center;
            padding: 2rem 1rem;
            background: #2c3e50;
            color: white;
            margin-top: 2rem;
        }
        
        a {
            color: #3498db;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <header>
        <h1>Christopher Howell Portfolio</h1>
        <p>Graphics and Tools Programming | c++ | c#</p>
    </header>
    
    <div class="container">

                <!-- Project 1 - Work -->
        <div class="project">
                        <div class="media-gallery">
                <video  controls autoplay loop muted>
                    <source src="assets/cut-crop.mp4" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
             
                <img src="assets/horse-short.gif" alt="Project 3 - Screenshot">
                <img src="assets/feet.jpg" alt="Project 3 - Screenshot">
            </div>
            <div class="project-content">
                <h2>Volume Rendering and Tools for Medical Data</h2>
                <p>Working on medical imaging software, 
                    optimizing and developing new features for DICOM data visualization across C++ and C# codebases.
                     This includes utilisting both DirectX11 and OpenGL for real-time 3D visualization of medical scans and 
                     providing tools for clinicians to modify how the data is represented and viewed.</p>
                <p>One tool I'd like to highlight is an arbitrary polygon selection tool that lets users isolate and exclude specific regions.
                     The system takes user-defined polygon points and uses an ear clipping algorithm to break the shape down into triangles.
                     The triangles are then transformed from screen space to 3D planes in world space to determine the zone to exclude from rendering.
                     During the ray marching pass, each ray is tested against these triangular masks to exclude unwanted regions from the render, 
                     giving clinicians precise control over what areas are 'cut' from the volumetric data.</p>
                
                <div class="tags">
                    <span class="tag">Directx11</span>
                    <span class="tag">OpenGL</span>
                    <span class="tag">C++</span>
                    <span class="tag">C#</span>
                    <span class="tag">HLSL</span>
                    <span class="tag">WPF</span>
                </div>
            </div>
        </div>
        <!-- Project 2 - Vulkan -->
        <div class="project">
                        <div class="media-gallery">
                <video controls>
                    <source src="assets/vulkan post.mp4" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
                <video controls>
                    <source src="assets/vulkan short.mp4" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
                <img src="assets/highlight.png" alt="Project 3 - Screenshot">
            </div>
            <div class="project-content">
                <h2>Vulkan Physically Based Rendering</h2>
 <p>Built a PBR scene viewer in Vulkan from scratch. This involved setting up the entire rendering pipeline including synchronization, memory management, and descriptor set layouts. For the shading model, I implemented Cook-Torrance BRDF with Beckmann normal distribution function, Schlick's Fresnel approximation, and Lambertian diffuse for accurate material representation.</p>
                <p>Added a multi-pass post-processing pipeline that renders the scene to an offscreen target first. 
                    Later passes sample from this texture to apply effects like color grading and tone mapping. 
                    Also built an object highlighting system that renders an object mask to a separate buffer,
                     then applies a Sobel edge detection filter in the post-process shader. 
                    The filter finds boundaries between masked objects and the scene, drawing a yellow highlight along the detected edges.</p>
                     <div class="tags">
                    <span class="tag">Vulkan</span>
                    <span class="tag">C++</span>
                    <span class="tag">HLSL</span>
                </div>
            </div>
        </div>
                <div class="project">
                        <div class="media-gallery">
                <video controls>
                    <source src="assets/Demo Lystem.mp4" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
               
                <img src="assets/tree1.png" alt="Tree 1">        
                <img src="assets/tree2.png" alt="Tree 2">
            </div>
            <div class="project-content">
                <h2>Unreal Engine - L-system procedural tree generator</h2>
 
                <p>I developed a fully procedural 3D L-systemâ€“based tree generator in Unreal Engine using C++. The system expands a formal grammar (axiom + production rules) into a sentence, then interprets it using a 3D turtle graphics algorithm to generate organic branching structures.

The generator is designed with performance in mind. All branch segments and leaves are rendered using Instanced Static Mesh Components, allowing thousands of meshes to be drawn in only a few draw calls. This makes the system scalable and suitable for real-time use, even at higher iteration counts.

Branch geometry is constructed at actor construction time (OnConstruction), avoiding per-frame overhead. A stack-based turtle state system enables efficient recursive branching, while quaternion-based local-axis rotations ensure stable orientation without gimbal lock. Branch thickness decreases based on stack depth, producing natural tapering at minimal computational cost.</p>
                    <p>The result is a compact, efficient procedural vegetation system capable of generating dense bushes or complex trees while maintaining strong runtime performance.
                     This tool can be used for rapid prototyping of vegetation assets or as a runtime foliage generator for dynamic environments.</p>

<div class="tags">
                    <span class="tag">Unreal Engine</span>
                    <span class="tag">C++</span>
                    <span class="tag">Blueprints</span>
                </div>
            </div>
        </div>
        
        <!-- Project 2 - Multiple Images -->
<div class="project">
            <div class="media-gallery">
                <img src="assets/grass.gif" alt="Grass rendering with wind simulation">
                <img src="assets/grassVis.png" alt="Perlin noise wind visualization">
            </div>
            <div class="project-content">
                <h2>Procedural Grass Rendering with Bezier Curves - Technical paper implementation</h2>
                <a href="grass.html">LIVE DEMO HERE</a>
                <p> </p>
                <p>Built a browser-based grass renderer that follows the paper 'Responsive Real-Time Grass Rendering for General 3D Scenes
                    - Klemens Jahrmann' and a GDC talk on Ghost of Tsushima's grass system. 
                    Each blade is modeled as a quadratic Bezier curve with three control points: P0 at the base, P1 at the tip,
                     and P2 controlling the bend.
                      The vertex shader evaluates these curves in real-time, offsetting vertices horizontally while maintaining blade length.
                       Wind movement is simulated using multiple octaves of scrolling Perlin noise at different scales, and the Bezier derivative calculates normals for lighting.</p>
                <p>Chose Three.js over WebGPU for better browser compatibility and development, allowing for the project to be easily shared over the web. Used instanced rendering to draw thousands of grass blades in a single draw call, with the tradeoff being no frustum culling.
                     Also added a cloud shadow effect by using Perlin noise to darken individual blades based on position, and built a debug UI to visualize wind intensity across the field.</p>
                <div class="tags">
                    <span class="tag">WebGL</span>
                    <span class="tag">Three.js</span>
                    <span class="tag">GLSL</span>
                    <span class="tag">JavaScript</span>
                    <span class="tag">Procedural Generation</span>
                </div>
            </div>
        </div>
        
       
        <!-- Project 4 - terrain tess-->
        <div class="project">
            <div class="media-gallery">
                <video controls autoplay loop muted>
                    <source src="assets/terrain short2.mp4" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
                <img src="assets/terraingif.gif" alt="Terrain tessellation visualization">
            </div>
            <div class="project-content">
                <h2>Terrain Tessellation with Dynamic LOD</h2>
                <p>Heightmap-based terrain renderer using tessellation shaders to dynamically adjust triangle density based on distance to camera. Closer terrain gets more subdivisions for detail, while distant areas use fewer triangles for performance. Used geometry shaders to procedurally generate grass and flower billboards across the landscape.</p>
                <p>Added a water layer using Gerstner wave equations with sinusoidal functions for realistic wave motion. 
                    Implemented a foam effect by blending a secondary texture based on proximity to the terrain, 
                    creating the appearance of water foam.</p>
                <div class="tags">
                    <span class="tag">OpenGL</span>
                    <span class="tag">C++</span>
                    <span class="tag">GLSL</span>
                    <span class="tag">Tessellation</span>
                    <span class="tag">ImGui</span>
                </div>
            </div>
        </div>
    </div>
    
    <footer>
        <p> 07846560995 | chrishowdev@outlook.com</p>
    </footer>
</body>

</html>
