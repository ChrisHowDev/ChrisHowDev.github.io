<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Static Example</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js",
            "three/examples/jsm/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/controls/OrbitControls.js",
            "three/examples/jsm/loaders/GLTFLoader": "https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/loaders/GLTFLoader.js"
        }
    }
</script>
 
  <script src="
https://cdn.jsdelivr.net/npm/three-orbitcontrols@2.110.3/OrbitControls.min.js
"></script>
  <script type="module">
  
  import * as THREE from "three";
  import * as dat from 'https://cdn.jsdelivr.net/npm/lil-gui@0.20/+esm';
  import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
  import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";




  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  scene.background = new THREE.Color(0x87CEEB);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);



  const vertexShader = /* glsl */ `

  uniform float time;
  uniform float windSpeed;
  uniform vec2 windDirection;
  uniform float grassLength;
  uniform float turbolance;
  uniform float grassLean;
  uniform vec3 playerPos;

  attribute vec3 instancePosition;

  varying float groundRand;
  varying float vY;
  varying vec3 bladeNormal;
  varying vec3 rotatedNormal1;
  varying vec3 rotatedNormal2;
  varying vec3 vPosition;
  varying float leanIntesity;
  varying float cloudColor;

  // Hash functions
  float hash(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
  }

  float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
  }

  // Classic Perlin noise helpers
  vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec4 permute(vec4 x) { return mod289(((x * 34.0) + 10.0) * x); }
  vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
  vec2 fade(vec2 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }

  // Classic Perlin noise
  float cnoise(vec2 P) {
    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
    Pi = mod289(Pi);
    vec4 ix = Pi.xzxz;
    vec4 iy = Pi.yyww;
    vec4 fx = Pf.xzxz;
    vec4 fy = Pf.yyww;

    vec4 i = permute(permute(ix) + iy);
    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;
    vec4 gy = abs(gx) - 0.5;
    vec4 tx = floor(gx + 0.5);
    gx -= tx;

    vec2 g00 = vec2(gx.x, gy.x);
    vec2 g10 = vec2(gx.y, gy.y);
    vec2 g01 = vec2(gx.z, gy.z);
    vec2 g11 = vec2(gx.w, gy.w);

    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
    g00 *= norm.x; g01 *= norm.y; g10 *= norm.z; g11 *= norm.w;

    float n00 = dot(g00, vec2(fx.x, fy.x));
    float n10 = dot(g10, vec2(fx.y, fy.y));
    float n01 = dot(g01, vec2(fx.z, fy.z));
    float n11 = dot(g11, vec2(fx.w, fy.w));

    vec2 fade_xy = fade(Pf.xy);
    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
    return 2.3 * mix(n_x.x, n_x.y, fade_xy.y);
  }

  // Bezier utilities
  vec3 Lerp(vec3 a, vec3 b, float t) {
    return a + t * (b - a);
  }

  vec3 bezierDerivative(vec3 p0, vec3 p1, vec3 p2, float t) {
    return 2.0 * (1.0 - t) * (p1 - p0) + 2.0 * t * (p2 - p1);
  }

  void MakePersistentLength(in vec3 v0, inout vec3 v1, inout vec3 v2, in float height) {
    vec3 v01 = v1 - v0;
    vec3 v12 = v2 - v1;
    float lv01 = length(v01);
    float lv12 = length(v12);
    float L1 = lv01 + lv12;
    float L0 = length(v2 - v0);
    float L = (2.0 * L0 + L1) / 3.0;
    float ldiff = height / L;
    v1 = v0 + v01 * ldiff;
    v2 = v1 + v12 * ldiff;
  }

  // Rotation
  mat3 rotation3dY(float angle) {
    float s = sin(angle);
    float c = cos(angle);
    return mat3(
      c, 0.0, -s,
      0.0, 1.0, 0.0,
      s, 0.0, c
    );
  }

  void main() {
    vec3 pos = position;

    // Random rotation per blade
    mat3 roty = rotation3dY(hash(instancePosition.xz) * 20.0);
    pos = pos * roty;

    // Wind noise values
    vec2 windPos = instancePosition.xz * turbolance + time * windSpeed * windDirection;
    float noiseValue = cnoise(windPos);

    windPos = instancePosition.xz * turbolance * 4.0 + time * windSpeed * 4.0 * windDirection;
    float noiseValue2 = cnoise(windPos);

    // Cloud color noise
    windPos = instancePosition.xz * 0.01 + time * windSpeed / 10.0 * windDirection;
    cloudColor = (cnoise(windPos) + 1.0) / 2.0;

    // Leaning intensity based on combined noise
    leanIntesity = ( (noiseValue + 1.0) / 2.0 + (noiseValue2 + 1.0) / 2.0 ) / 2.0;

    // Ground randomness
    windPos = instancePosition.xz * 0.02;
    groundRand = clamp((cnoise(windPos) + 1.0) / 2.0, 0.5, 1.0);

    // Blade direction and height
    vec3 bladeDirection = normalize(vec3(-windDirection.x, 0.0, -windDirection.y));
    vec3 bladeHeight = vec3(0.0, grassLength, 0.0);

    // Player influence
    float distanceToPlayer = length(playerPos - instancePosition);
    float influence = max(0.0, 30.0 - (distanceToPlayer / 0.2));
    float grassLeaning = max(grassLean + (2.5 * influence), 5.0);
    vec3 awayFromPlayer = normalize(instancePosition - playerPos);
    vec3 combinedDirection = normalize(bladeDirection + awayFromPlayer * influence);

    // Bezier control points
    vec3 p0 = vec3(0.0);
    vec3 p1 = bladeHeight;
    vec3 p2 = (grassLeaning + 0.5) * leanIntesity * combinedDirection + bladeHeight;
    float t = clamp(pos.y, 0.0, 1.0);

    MakePersistentLength(p0, p1, p2, grassLength);

    // Interpolate along curve
    vec3 a = Lerp(p0, p1, t);
    vec3 b = Lerp(p1, p2, t);
    vec3 c = Lerp(a, b, t);

    vY = pos.y;
    pos += c + instancePosition;
    pos.y -= sin(hash(instancePosition.xz));

    // Normals
    vec3 tangent = bezierDerivative(p0, p1, p2, t);
    vec3 newDirection = p1 - p2;
    vec3 sideVec = normalize(vec3(newDirection.z, newDirection.y, -newDirection.x));
    vec3 normal = normalize(cross(sideVec, tangent));

    bladeNormal = roty * normal;
    vPosition = pos;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
  }
  `;

  const fragmentShaders = {
  phong_shading: /* glsl */ `
    varying float vY;
    varying vec3 bladeNormal;
    varying vec3 vPosition;
    varying float leanIntesity;
    varying float groundRand;
    varying float cloudColor;
    varying vec3 rotatedNormal1;
    varying vec3 rotatedNormal2;

    uniform vec3 lightPosition;
    uniform vec3 viewPosition;

    void main() {
      // Material colors
      vec3 ambientColor = vec3(0.2, 0.4, 0.2);
      vec3 diffuseColor = vec3(0.2, 0.5 + groundRand, 0.2);

      // Phong lighting parameters
      float shininess = 128.0;

      // Normalize the normal vector
      vec3 N = normalize(bladeNormal);

      // Directional light direction (hardcoded as directional)
      vec3 L = normalize(-lightPosition);

      // Reflection vector (unused, as no specular applied)
      vec3 R = reflect(-L, N);

      // Lighting components
      vec3 ambient = ambientColor;
      float diff = max(dot(N, L), 0.0);
      vec3 diffuse = diff * diffuseColor * cloudColor;

      // Final color (diffuse + ambient)
      vec3 color = diffuse + ambient;

      gl_FragColor = vec4(color, 1.0);
    }
  `,

  perlin_wind_vis: /* glsl */ `
    varying float vY;
    varying vec3 bladeNormal;
    varying vec3 vPosition;
    varying float leanIntesity;

    uniform vec3 lightPosition;
    uniform vec3 viewPosition;

    void main() {
      // Visualize lean intensity as grayscale
      vec3 color = vec3(leanIntesity);
      gl_FragColor = vec4(color, 1.0);
    }
  `,

  normals_vis: /* glsl */ `
    varying float vY;
    varying vec3 bladeNormal;
    varying vec3 vPosition;
    varying float leanIntesity;

    uniform vec3 lightPosition;
    uniform vec3 viewPosition;

    void main() {
      // Visualize normals (abs to bring values into [0, 1])
      vec3 color = abs(bladeNormal);
      gl_FragColor = vec4(color, 1.0);
    }
  `,

  flat_shading: /* glsl */ `
    varying float vY;
    varying vec3 bladeNormal;
    varying vec3 vPosition;
    varying float leanIntesity;
    varying float cloudColor;

    uniform vec3 lightPosition;
    uniform vec3 viewPosition;

    void main() {
      // Vertical color gradient based on blade height (vY)
      float greenIntensity = 1.0 * vY;
      float redIntensity = 0.2 * vY;

      // Adjust color based on cloud cover
      vec3 color = vec3(redIntensity, greenIntensity, 0.1) * (cloudColor + 0.5);

      gl_FragColor = vec4(color, 1.0);
    }
  `
};


// Shader update function
function updateShader() {
  material.fragmentShader = fragmentShaders[options.shader];
  material.needsUpdate = true;
}

// Light position
const lightPos = new THREE.Vector3(1, -100, 1);

// UI options
const options = {
  shader: 'phong_shading',
  windSpeed: 0.3,
  grassLength: 8,
  turbolance: 0.05,
  grassLean: 10,
  windAngle: 0.0,
  grassArea: 50,
  grassDensity: 10000
};

// dat.GUI setup
const gui = new dat.GUI();
gui.add(options, 'shader', Object.keys(fragmentShaders)).name('Debug View').onChange(updateShader);
gui.add(options, 'windSpeed', 0, 2.5).name('Wind Speed');
gui.add(options, 'turbolance', 0, 0.1).name('Wind Turbolance');
gui.add(options, 'grassLength', 0.5, 10).name('Grass Length');
gui.add(options, 'grassLean', 0, 25).name('Grass Leaning');
gui.add(options, 'grassArea', 50, 500).name('Grass Area').onChange(updateGrass);
gui.add(options, 'grassDensity', 1000, 800000).name('Grass Blades').onChange(updateGrass);

// Wind direction calculation
const windDirection = { x: 1.0, y: 1.0 };
gui.add(options, 'windAngle', 0, 360).name('Wind Direction').onChange(() => {
  const radians = options.windAngle * Math.PI / 180;
  windDirection.x = Math.sin(radians);
  windDirection.y = Math.cos(radians);
  material.uniforms.windDirection.value.set(windDirection.x, windDirection.y);
});

// Load animated character
let character, mixer, actions = {};
const loader = new GLTFLoader();
loader.load("https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb", (gltf) => {
  character = gltf.scene;
  character.scale.set(2, 2, 2);
  character.position.set(0, 0, 0);
  scene.add(character);

  mixer = new THREE.AnimationMixer(character);
  gltf.animations.forEach((clip) => {
    actions[clip.name] = mixer.clipAction(clip);
  });
  actions["Idle"].play();
});

// Character controls
const keys = { w: false, s: false, a: false, d: false };
window.addEventListener("keydown", (e) => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup", (e) => keys[e.key.toLowerCase()] = false);

function playAnimation(name) {
  if (actions[name] && currentAction !== actions[name]) {
    if (currentAction) currentAction.fadeOut(0.2);
    currentAction = actions[name];
    currentAction.reset().fadeIn(0.2).play();
  }
}

let speed = 0.25;
let currentAction = null;
let characterPos = new THREE.Vector3(0, 0, 0);

// Shader material setup
const material = new THREE.ShaderMaterial({
  vertexShader: vertexShader,
  fragmentShader: fragmentShaders[options.shader],
  side: THREE.DoubleSide,
  uniforms: {
    time: { value: 0.0 },
    cameraPosition: { value: camera.position },
    lightPosition: { value: lightPos },
    windSpeed: { value: options.windSpeed },
    grassLength: { value: options.grassLength },
    turbolance: { value: options.turbolance },
    grassLean: { value: options.grassLean },
    windDirection: { value: new THREE.Vector2(1.0, 1.0) },
    playerPos: { value: characterPos }
  }
});

// Grass geometry + instancing
const grassGeometry = new THREE.PlaneGeometry(0.17, 1, 1, 12);
let instancedMesh;

function updateGrass() {
  const grassCount = options.grassDensity;
  const positions = [];

  for (let i = 0; i < grassCount; i++) {
    positions.push(Math.random() * options.grassArea - options.grassArea / 2); // x
    positions.push(0.5);                                                       // y
    positions.push(Math.random() * options.grassArea - options.grassArea / 2); // z
  }

  const instancedGeometry = new THREE.InstancedBufferGeometry().copy(grassGeometry);
  instancedGeometry.setAttribute('instancePosition', new THREE.InstancedBufferAttribute(new Float32Array(positions), 3));

  if (instancedMesh) scene.remove(instancedMesh);
  instancedMesh = new THREE.InstancedMesh(instancedGeometry, material, grassCount);
  scene.add(instancedMesh);
}

updateGrass();

// Ground setup
const groundGeometry = new THREE.PlaneGeometry(500, 500);
const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x228B22 });
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

// Camera setup
camera.position.set(0, 10, 40);
camera.up.set(0, 1, 0);
camera.lookAt(0, 10, 0);
camera.updateProjectionMatrix();

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

// Lighting
const ambientLight = new THREE.AmbientLight(0xffffff, 1);
scene.add(ambientLight);

// Animation loop
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();

  controls.update();
  if (mixer) mixer.update(0.02);

// Character Movement relative to camera
  if (character) {
      const moveVector = new THREE.Vector3();
      const forward = new THREE.Vector3();
      const right = new THREE.Vector3();

      // Get the camera's forward direction
      camera.getWorldDirection(forward);
      forward.y = 0; // Keep movement on XZ plane
      forward.normalize();

      // Get the right vector by crossing forward with up vector
      right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

      // Accumulate move direction based on key states
      if (keys.w) moveVector.add(forward);
      if (keys.s) moveVector.sub(forward);
      if (keys.a) moveVector.sub(right);
      if (keys.d) moveVector.add(right);

      if (moveVector.lengthSq() > 0) {
          moveVector.normalize();
          character.position.add(moveVector.multiplyScalar(speed));
          character.lookAt(character.position.clone().add(moveVector)); // Face move direction
          playAnimation("Walking");
      } else {
          playAnimation("Idle");
      }
  }

  // Update character position uniform
  characterPos.copy(character ? character.position : new THREE.Vector3(0, 0, 0));

  // Update shader uniforms
  material.uniforms.lightPosition.value = lightPos;
  material.uniforms.windSpeed.value = options.windSpeed;
  material.uniforms.grassLength.value = options.grassLength;
  material.uniforms.turbolance.value = options.turbolance;
  material.uniforms.grassLean.value = options.grassLean;
  material.uniforms.time.value = clock.getElapsedTime();
  material.uniforms.cameraPosition.value.copy(camera.position);

  renderer.render(scene, camera);
}

animate();

// Handle window resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});



  </script>

</body>
</html>